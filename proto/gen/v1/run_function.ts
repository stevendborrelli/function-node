// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: v1/run_function.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Duration } from "../google/protobuf/duration.js";
import { Struct } from "../google/protobuf/struct.js";

export const protobufPackage = "apiextensions.fn.proto.v1";

/** Ready indicates whether a composed resource should be considered ready. */
export enum Ready {
  READY_UNSPECIFIED = 0,
  /** READY_TRUE - True means the composed resource has been observed to be ready. */
  READY_TRUE = 1,
  /** READY_FALSE - False means the composed resource has not been observed to be ready. */
  READY_FALSE = 2,
  UNRECOGNIZED = -1,
}

export function readyFromJSON(object: any): Ready {
  switch (object) {
    case 0:
    case "READY_UNSPECIFIED":
      return Ready.READY_UNSPECIFIED;
    case 1:
    case "READY_TRUE":
      return Ready.READY_TRUE;
    case 2:
    case "READY_FALSE":
      return Ready.READY_FALSE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Ready.UNRECOGNIZED;
  }
}

export function readyToJSON(object: Ready): string {
  switch (object) {
    case Ready.READY_UNSPECIFIED:
      return "READY_UNSPECIFIED";
    case Ready.READY_TRUE:
      return "READY_TRUE";
    case Ready.READY_FALSE:
      return "READY_FALSE";
    case Ready.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Severity of Function results. */
export enum Severity {
  SEVERITY_UNSPECIFIED = 0,
  /**
   * SEVERITY_FATAL - Fatal results are fatal; subsequent Composition Functions may run, but
   * the Composition Function pipeline run will be considered a failure and
   * the first fatal result will be returned as an error.
   */
  SEVERITY_FATAL = 1,
  /**
   * SEVERITY_WARNING - Warning results are non-fatal; the entire Composition will run to
   * completion but warning events and debug logs associated with the
   * composite resource will be emitted.
   */
  SEVERITY_WARNING = 2,
  /**
   * SEVERITY_NORMAL - Normal results are emitted as normal events and debug logs associated
   * with the composite resource.
   */
  SEVERITY_NORMAL = 3,
  UNRECOGNIZED = -1,
}

export function severityFromJSON(object: any): Severity {
  switch (object) {
    case 0:
    case "SEVERITY_UNSPECIFIED":
      return Severity.SEVERITY_UNSPECIFIED;
    case 1:
    case "SEVERITY_FATAL":
      return Severity.SEVERITY_FATAL;
    case 2:
    case "SEVERITY_WARNING":
      return Severity.SEVERITY_WARNING;
    case 3:
    case "SEVERITY_NORMAL":
      return Severity.SEVERITY_NORMAL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Severity.UNRECOGNIZED;
  }
}

export function severityToJSON(object: Severity): string {
  switch (object) {
    case Severity.SEVERITY_UNSPECIFIED:
      return "SEVERITY_UNSPECIFIED";
    case Severity.SEVERITY_FATAL:
      return "SEVERITY_FATAL";
    case Severity.SEVERITY_WARNING:
      return "SEVERITY_WARNING";
    case Severity.SEVERITY_NORMAL:
      return "SEVERITY_NORMAL";
    case Severity.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Target of Function results and conditions. */
export enum Target {
  /** TARGET_UNSPECIFIED - If the target is unspecified, the result targets the composite resource. */
  TARGET_UNSPECIFIED = 0,
  /**
   * TARGET_COMPOSITE - Target the composite resource. Results that target the composite resource
   * should include detailed, advanced information.
   */
  TARGET_COMPOSITE = 1,
  /**
   * TARGET_COMPOSITE_AND_CLAIM - Target the composite and the claim. Results that target the composite and
   * the claim should include only end-user friendly information.
   */
  TARGET_COMPOSITE_AND_CLAIM = 2,
  UNRECOGNIZED = -1,
}

export function targetFromJSON(object: any): Target {
  switch (object) {
    case 0:
    case "TARGET_UNSPECIFIED":
      return Target.TARGET_UNSPECIFIED;
    case 1:
    case "TARGET_COMPOSITE":
      return Target.TARGET_COMPOSITE;
    case 2:
    case "TARGET_COMPOSITE_AND_CLAIM":
      return Target.TARGET_COMPOSITE_AND_CLAIM;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Target.UNRECOGNIZED;
  }
}

export function targetToJSON(object: Target): string {
  switch (object) {
    case Target.TARGET_UNSPECIFIED:
      return "TARGET_UNSPECIFIED";
    case Target.TARGET_COMPOSITE:
      return "TARGET_COMPOSITE";
    case Target.TARGET_COMPOSITE_AND_CLAIM:
      return "TARGET_COMPOSITE_AND_CLAIM";
    case Target.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum Status {
  STATUS_CONDITION_UNSPECIFIED = 0,
  STATUS_CONDITION_UNKNOWN = 1,
  STATUS_CONDITION_TRUE = 2,
  STATUS_CONDITION_FALSE = 3,
  UNRECOGNIZED = -1,
}

export function statusFromJSON(object: any): Status {
  switch (object) {
    case 0:
    case "STATUS_CONDITION_UNSPECIFIED":
      return Status.STATUS_CONDITION_UNSPECIFIED;
    case 1:
    case "STATUS_CONDITION_UNKNOWN":
      return Status.STATUS_CONDITION_UNKNOWN;
    case 2:
    case "STATUS_CONDITION_TRUE":
      return Status.STATUS_CONDITION_TRUE;
    case 3:
    case "STATUS_CONDITION_FALSE":
      return Status.STATUS_CONDITION_FALSE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Status.UNRECOGNIZED;
  }
}

export function statusToJSON(object: Status): string {
  switch (object) {
    case Status.STATUS_CONDITION_UNSPECIFIED:
      return "STATUS_CONDITION_UNSPECIFIED";
    case Status.STATUS_CONDITION_UNKNOWN:
      return "STATUS_CONDITION_UNKNOWN";
    case Status.STATUS_CONDITION_TRUE:
      return "STATUS_CONDITION_TRUE";
    case Status.STATUS_CONDITION_FALSE:
      return "STATUS_CONDITION_FALSE";
    case Status.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** A RunFunctionRequest requests that the Composition Function be run. */
export interface RunFunctionRequest {
  /** Metadata pertaining to this request. */
  meta?:
    | RequestMeta
    | undefined;
  /**
   * The observed state prior to invocation of a Function pipeline. State passed
   * to each Function is fresh as of the time the pipeline was invoked, not as
   * of the time each Function was invoked.
   */
  observed?:
    | State
    | undefined;
  /**
   * Desired state according to a Function pipeline. The state passed to a
   * particular Function may have been accumulated by previous Functions in the
   * pipeline.
   *
   * Note that the desired state must be a partial object with only the fields
   * that this function (and its predecessors in the pipeline) wants to have
   * set in the object. Copying a non-partial observed state to desired is most
   * likely not what you want to do. Leaving out fields that had been returned
   * as desired before will result in them being deleted from the objects in the
   * cluster.
   */
  desired?:
    | State
    | undefined;
  /**
   * Optional input specific to this Function invocation. A JSON representation
   * of the 'input' block of the relevant entry in a Composition's pipeline.
   */
  input?:
    | { [key: string]: any }
    | undefined;
  /**
   * Optional context. Crossplane may pass arbitary contextual information to a
   * Function. A Function may also return context in its RunFunctionResponse,
   * and that context will be passed to subsequent Functions. Crossplane
   * discards all context returned by the last Function in the pipeline.
   */
  context?:
    | { [key: string]: any }
    | undefined;
  /**
   * Optional extra resources that the Function required.
   * Note that extra resources is a map to Resources, plural.
   * The map key corresponds to the key in a RunFunctionResponse's
   * extra_resources field. If a Function requested extra resources that
   * did not exist, Crossplane sets the map key to an empty Resources message to
   * indicate that it attempted to satisfy the request.
   */
  extraResources?:
    | { [key: string]: Resources }
    | undefined;
  /**
   * Optional credentials that this Function may use to communicate with an
   * external system.
   */
  credentials?: { [key: string]: Credentials } | undefined;
}

export interface RunFunctionRequest_ExtraResourcesEntry {
  key: string;
  value?: Resources | undefined;
}

export interface RunFunctionRequest_CredentialsEntry {
  key: string;
  value?: Credentials | undefined;
}

/** Credentials that a Function may use to communicate with an external system. */
export interface Credentials {
  /** Credential data loaded by Crossplane, for example from a Secret. */
  credentialData?: CredentialData | undefined;
}

/** CredentialData loaded by Crossplane, for example from a Secret. */
export interface CredentialData {
  data?: { [key: string]: Uint8Array } | undefined;
}

export interface CredentialData_DataEntry {
  key: string;
  value: Uint8Array;
}

/** Resources represents the state of several Crossplane resources. */
export interface Resources {
  items?: Resource[] | undefined;
}

/** A RunFunctionResponse contains the result of a Composition Function run. */
export interface RunFunctionResponse {
  /** Metadata pertaining to this response. */
  meta?:
    | ResponseMeta
    | undefined;
  /**
   * Desired state according to a Function pipeline. Functions may add desired
   * state, and may mutate or delete any part of the desired state they are
   * concerned with. A Function must pass through any part of the desired state
   * that it is not concerned with.
   *
   * Note that the desired state must be a partial object with only the fields
   * that this function (and its predecessors in the pipeline) wants to have
   * set in the object. Copying a non-partial observed state to desired is most
   * likely not what you want to do. Leaving out fields that had been returned
   * as desired before will result in them being deleted from the objects in the
   * cluster.
   */
  desired?:
    | State
    | undefined;
  /** Results of the Function run. Results are used for observability purposes. */
  results?:
    | Result[]
    | undefined;
  /**
   * Optional context to be passed to the next Function in the pipeline as part
   * of the RunFunctionRequest. Dropped on the last function in the pipeline.
   */
  context?:
    | { [key: string]: any }
    | undefined;
  /** Requirements that must be satisfied for this Function to run successfully. */
  requirements?:
    | Requirements
    | undefined;
  /**
   * Status conditions to be applied to the composite resource. Conditions may also
   * optionally be applied to the composite resource's associated claim.
   */
  conditions?: Condition[] | undefined;
}

/** RequestMeta contains metadata pertaining to a RunFunctionRequest. */
export interface RequestMeta {
  /**
   * An opaque string identifying the content of the request. Two identical
   * requests should have the same tag.
   */
  tag?: string | undefined;
}

/** Requirements that must be satisfied for a Function to run successfully. */
export interface Requirements {
  /**
   * Extra resources that this Function requires.
   * The map key uniquely identifies the group of resources.
   */
  extraResources?: { [key: string]: ResourceSelector } | undefined;
}

export interface Requirements_ExtraResourcesEntry {
  key: string;
  value?: ResourceSelector | undefined;
}

/** ResourceSelector selects a group of resources, either by name or by label. */
export interface ResourceSelector {
  /** API version of resources to select. */
  apiVersion?:
    | string
    | undefined;
  /** Kind of resources to select. */
  kind?:
    | string
    | undefined;
  /** Match the resource with this name. */
  matchName?:
    | string
    | undefined;
  /** Match all resources with these labels. */
  matchLabels?: MatchLabels | undefined;
}

/** MatchLabels defines a set of labels to match resources against. */
export interface MatchLabels {
  labels?: { [key: string]: string } | undefined;
}

export interface MatchLabels_LabelsEntry {
  key: string;
  value: string;
}

/** ResponseMeta contains metadata pertaining to a RunFunctionResponse. */
export interface ResponseMeta {
  /**
   * An opaque string identifying the content of the request. Must match the
   * meta.tag of the corresponding RunFunctionRequest.
   */
  tag?:
    | string
    | undefined;
  /**
   * Time-to-live of this response. Deterministic Functions with no side-effects
   * (e.g. simple templating Functions) may specify a TTL. Crossplane may choose
   * to cache responses until the TTL expires.
   */
  ttl?: Duration | undefined;
}

/** State of the composite resource (XR) and any composed resources. */
export interface State {
  /** The state of the composite resource (XR). */
  composite?:
    | Resource
    | undefined;
  /** The state of any composed resources. */
  resources?: { [key: string]: Resource } | undefined;
}

export interface State_ResourcesEntry {
  key: string;
  value?: Resource | undefined;
}

/** A Resource represents the state of a composite or composed resource. */
export interface Resource {
  /**
   * The JSON representation of the resource.
   *
   * * Crossplane will set this field in a RunFunctionRequest to the entire
   *   observed state of a resource - including its metadata, spec, and status.
   *
   * * A Function should set this field in a RunFunctionRequest to communicate
   *   the desired state of a composite or composed resource.
   *
   * * A Function may only specify the desired status of a composite resource -
   *   not its metadata or spec. A Function should not return desired metadata
   *   or spec for a composite resource. This will be ignored.
   *
   * * A Function may not specify the desired status of a composed resource -
   *   only its metadata and spec. A Function should not return desired status
   *   for a composed resource. This will be ignored.
   */
  resource?:
    | { [key: string]: any }
    | undefined;
  /**
   * The resource's connection details.
   *
   * * Crossplane will set this field in a RunFunctionRequest to communicate the
   *   the observed connection details of a composite or composed resource.
   *
   * * A Function should set this field in a RunFunctionResponse to indicate the
   *   desired connection details of the composite resource.
   *
   * * A Function should not set this field in a RunFunctionResponse to indicate
   *   the desired connection details of a composed resource. This will be
   *   ignored.
   */
  connectionDetails?:
    | { [key: string]: Uint8Array }
    | undefined;
  /**
   * Ready indicates whether the resource should be considered ready.
   *
   * * Crossplane will never set this field in a RunFunctionRequest.
   *
   * * A Function should set this field to READY_TRUE in a RunFunctionResponse
   *   to indicate that a desired composed resource is ready.
   *
   * * A Function should not set this field in a RunFunctionResponse to indicate
   *   that the desired composite resource is ready. This will be ignored.
   */
  ready?: Ready | undefined;
}

export interface Resource_ConnectionDetailsEntry {
  key: string;
  value: Uint8Array;
}

/** A Result of running a Function. */
export interface Result {
  /** Severity of this result. */
  severity?:
    | Severity
    | undefined;
  /** Human-readable details about the result. */
  message?:
    | string
    | undefined;
  /**
   * Optional PascalCase, machine-readable reason for this result. If omitted,
   * the value will be ComposeResources.
   */
  reason?:
    | string
    | undefined;
  /** The resources this result targets. */
  target?: Target | undefined;
}

/**
 * Status condition to be applied to the composite resource. Condition may also
 * optionally be applied to the composite resource's associated claim. For
 * detailed information on proper usage of status conditions, please see
 * https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#typical-status-properties.
 */
export interface Condition {
  /** Type of condition in PascalCase. */
  type?:
    | string
    | undefined;
  /** Status of the condition. */
  status?:
    | Status
    | undefined;
  /**
   * Reason contains a programmatic identifier indicating the reason for the
   * condition's last transition. Producers of specific condition types may
   * define expected values and meanings for this field, and whether the values
   * are considered a guaranteed API. The value should be a PascalCase string.
   * This field may not be empty.
   */
  reason?:
    | string
    | undefined;
  /**
   * Message is a human readable message indicating details about the
   * transition. This may be an empty string.
   */
  message?:
    | string
    | undefined;
  /** The resources this condition targets. */
  target?: Target | undefined;
}

function createBaseRunFunctionRequest(): RunFunctionRequest {
  return {
    meta: undefined,
    observed: undefined,
    desired: undefined,
    input: undefined,
    context: undefined,
    extraResources: {},
    credentials: {},
  };
}

export const RunFunctionRequest: MessageFns<RunFunctionRequest> = {
  encode(message: RunFunctionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.meta !== undefined) {
      RequestMeta.encode(message.meta, writer.uint32(10).fork()).join();
    }
    if (message.observed !== undefined) {
      State.encode(message.observed, writer.uint32(18).fork()).join();
    }
    if (message.desired !== undefined) {
      State.encode(message.desired, writer.uint32(26).fork()).join();
    }
    if (message.input !== undefined) {
      Struct.encode(Struct.wrap(message.input), writer.uint32(34).fork()).join();
    }
    if (message.context !== undefined) {
      Struct.encode(Struct.wrap(message.context), writer.uint32(42).fork()).join();
    }
    Object.entries(message.extraResources || {}).forEach(([key, value]) => {
      RunFunctionRequest_ExtraResourcesEntry.encode({ key: key as any, value }, writer.uint32(50).fork()).join();
    });
    Object.entries(message.credentials || {}).forEach(([key, value]) => {
      RunFunctionRequest_CredentialsEntry.encode({ key: key as any, value }, writer.uint32(58).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunFunctionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunFunctionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.meta = RequestMeta.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.observed = State.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.desired = State.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.input = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.context = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          const entry6 = RunFunctionRequest_ExtraResourcesEntry.decode(reader, reader.uint32());
          if (entry6.value !== undefined) {
            message.extraResources![entry6.key] = entry6.value;
          }
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          const entry7 = RunFunctionRequest_CredentialsEntry.decode(reader, reader.uint32());
          if (entry7.value !== undefined) {
            message.credentials![entry7.key] = entry7.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RunFunctionRequest {
    return {
      meta: isSet(object.meta) ? RequestMeta.fromJSON(object.meta) : undefined,
      observed: isSet(object.observed) ? State.fromJSON(object.observed) : undefined,
      desired: isSet(object.desired) ? State.fromJSON(object.desired) : undefined,
      input: isObject(object.input) ? object.input : undefined,
      context: isObject(object.context) ? object.context : undefined,
      extraResources: isObject(object.extraResources)
        ? Object.entries(object.extraResources).reduce<{ [key: string]: Resources }>((acc, [key, value]) => {
          acc[key] = Resources.fromJSON(value);
          return acc;
        }, {})
        : {},
      credentials: isObject(object.credentials)
        ? Object.entries(object.credentials).reduce<{ [key: string]: Credentials }>((acc, [key, value]) => {
          acc[key] = Credentials.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: RunFunctionRequest): unknown {
    const obj: any = {};
    if (message.meta !== undefined) {
      obj.meta = RequestMeta.toJSON(message.meta);
    }
    if (message.observed !== undefined) {
      obj.observed = State.toJSON(message.observed);
    }
    if (message.desired !== undefined) {
      obj.desired = State.toJSON(message.desired);
    }
    if (message.input !== undefined) {
      obj.input = message.input;
    }
    if (message.context !== undefined) {
      obj.context = message.context;
    }
    if (message.extraResources) {
      const entries = Object.entries(message.extraResources);
      if (entries.length > 0) {
        obj.extraResources = {};
        entries.forEach(([k, v]) => {
          obj.extraResources[k] = Resources.toJSON(v);
        });
      }
    }
    if (message.credentials) {
      const entries = Object.entries(message.credentials);
      if (entries.length > 0) {
        obj.credentials = {};
        entries.forEach(([k, v]) => {
          obj.credentials[k] = Credentials.toJSON(v);
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<RunFunctionRequest>): RunFunctionRequest {
    return RunFunctionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RunFunctionRequest>): RunFunctionRequest {
    const message = createBaseRunFunctionRequest();
    message.meta = (object.meta !== undefined && object.meta !== null)
      ? RequestMeta.fromPartial(object.meta)
      : undefined;
    message.observed = (object.observed !== undefined && object.observed !== null)
      ? State.fromPartial(object.observed)
      : undefined;
    message.desired = (object.desired !== undefined && object.desired !== null)
      ? State.fromPartial(object.desired)
      : undefined;
    message.input = object.input ?? undefined;
    message.context = object.context ?? undefined;
    message.extraResources = Object.entries(object.extraResources ?? {}).reduce<{ [key: string]: Resources }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = Resources.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.credentials = Object.entries(object.credentials ?? {}).reduce<{ [key: string]: Credentials }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = Credentials.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseRunFunctionRequest_ExtraResourcesEntry(): RunFunctionRequest_ExtraResourcesEntry {
  return { key: "", value: undefined };
}

export const RunFunctionRequest_ExtraResourcesEntry: MessageFns<RunFunctionRequest_ExtraResourcesEntry> = {
  encode(message: RunFunctionRequest_ExtraResourcesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Resources.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunFunctionRequest_ExtraResourcesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunFunctionRequest_ExtraResourcesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = Resources.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RunFunctionRequest_ExtraResourcesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Resources.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: RunFunctionRequest_ExtraResourcesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Resources.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<RunFunctionRequest_ExtraResourcesEntry>): RunFunctionRequest_ExtraResourcesEntry {
    return RunFunctionRequest_ExtraResourcesEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RunFunctionRequest_ExtraResourcesEntry>): RunFunctionRequest_ExtraResourcesEntry {
    const message = createBaseRunFunctionRequest_ExtraResourcesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? Resources.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseRunFunctionRequest_CredentialsEntry(): RunFunctionRequest_CredentialsEntry {
  return { key: "", value: undefined };
}

export const RunFunctionRequest_CredentialsEntry: MessageFns<RunFunctionRequest_CredentialsEntry> = {
  encode(message: RunFunctionRequest_CredentialsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Credentials.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunFunctionRequest_CredentialsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunFunctionRequest_CredentialsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = Credentials.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RunFunctionRequest_CredentialsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Credentials.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: RunFunctionRequest_CredentialsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Credentials.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<RunFunctionRequest_CredentialsEntry>): RunFunctionRequest_CredentialsEntry {
    return RunFunctionRequest_CredentialsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RunFunctionRequest_CredentialsEntry>): RunFunctionRequest_CredentialsEntry {
    const message = createBaseRunFunctionRequest_CredentialsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? Credentials.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseCredentials(): Credentials {
  return { credentialData: undefined };
}

export const Credentials: MessageFns<Credentials> = {
  encode(message: Credentials, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.credentialData !== undefined) {
      CredentialData.encode(message.credentialData, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Credentials {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCredentials();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.credentialData = CredentialData.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Credentials {
    return {
      credentialData: isSet(object.credentialData) ? CredentialData.fromJSON(object.credentialData) : undefined,
    };
  },

  toJSON(message: Credentials): unknown {
    const obj: any = {};
    if (message.credentialData !== undefined) {
      obj.credentialData = CredentialData.toJSON(message.credentialData);
    }
    return obj;
  },

  create(base?: DeepPartial<Credentials>): Credentials {
    return Credentials.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Credentials>): Credentials {
    const message = createBaseCredentials();
    message.credentialData = (object.credentialData !== undefined && object.credentialData !== null)
      ? CredentialData.fromPartial(object.credentialData)
      : undefined;
    return message;
  },
};

function createBaseCredentialData(): CredentialData {
  return { data: {} };
}

export const CredentialData: MessageFns<CredentialData> = {
  encode(message: CredentialData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.data || {}).forEach(([key, value]) => {
      CredentialData_DataEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CredentialData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCredentialData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          const entry1 = CredentialData_DataEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.data![entry1.key] = entry1.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CredentialData {
    return {
      data: isObject(object.data)
        ? Object.entries(object.data).reduce<{ [key: string]: Uint8Array }>((acc, [key, value]) => {
          acc[key] = bytesFromBase64(value as string);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: CredentialData): unknown {
    const obj: any = {};
    if (message.data) {
      const entries = Object.entries(message.data);
      if (entries.length > 0) {
        obj.data = {};
        entries.forEach(([k, v]) => {
          obj.data[k] = base64FromBytes(v);
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<CredentialData>): CredentialData {
    return CredentialData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CredentialData>): CredentialData {
    const message = createBaseCredentialData();
    message.data = Object.entries(object.data ?? {}).reduce<{ [key: string]: Uint8Array }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = value;
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseCredentialData_DataEntry(): CredentialData_DataEntry {
  return { key: "", value: new Uint8Array(0) };
}

export const CredentialData_DataEntry: MessageFns<CredentialData_DataEntry> = {
  encode(message: CredentialData_DataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value.length !== 0) {
      writer.uint32(18).bytes(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CredentialData_DataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCredentialData_DataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CredentialData_DataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? bytesFromBase64(object.value) : new Uint8Array(0),
    };
  },

  toJSON(message: CredentialData_DataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value.length !== 0) {
      obj.value = base64FromBytes(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<CredentialData_DataEntry>): CredentialData_DataEntry {
    return CredentialData_DataEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CredentialData_DataEntry>): CredentialData_DataEntry {
    const message = createBaseCredentialData_DataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? new Uint8Array(0);
    return message;
  },
};

function createBaseResources(): Resources {
  return { items: [] };
}

export const Resources: MessageFns<Resources> = {
  encode(message: Resources, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.items !== undefined && message.items.length !== 0) {
      for (const v of message.items) {
        Resource.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Resources {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResources();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.items!.push(Resource.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Resources {
    return { items: globalThis.Array.isArray(object?.items) ? object.items.map((e: any) => Resource.fromJSON(e)) : [] };
  },

  toJSON(message: Resources): unknown {
    const obj: any = {};
    if (message.items?.length) {
      obj.items = message.items.map((e) => Resource.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Resources>): Resources {
    return Resources.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Resources>): Resources {
    const message = createBaseResources();
    message.items = object.items?.map((e) => Resource.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRunFunctionResponse(): RunFunctionResponse {
  return {
    meta: undefined,
    desired: undefined,
    results: [],
    context: undefined,
    requirements: undefined,
    conditions: [],
  };
}

export const RunFunctionResponse: MessageFns<RunFunctionResponse> = {
  encode(message: RunFunctionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.meta !== undefined) {
      ResponseMeta.encode(message.meta, writer.uint32(10).fork()).join();
    }
    if (message.desired !== undefined) {
      State.encode(message.desired, writer.uint32(18).fork()).join();
    }
    if (message.results !== undefined && message.results.length !== 0) {
      for (const v of message.results) {
        Result.encode(v!, writer.uint32(26).fork()).join();
      }
    }
    if (message.context !== undefined) {
      Struct.encode(Struct.wrap(message.context), writer.uint32(34).fork()).join();
    }
    if (message.requirements !== undefined) {
      Requirements.encode(message.requirements, writer.uint32(42).fork()).join();
    }
    if (message.conditions !== undefined && message.conditions.length !== 0) {
      for (const v of message.conditions) {
        Condition.encode(v!, writer.uint32(50).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunFunctionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunFunctionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.meta = ResponseMeta.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.desired = State.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.results!.push(Result.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.context = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.requirements = Requirements.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.conditions!.push(Condition.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RunFunctionResponse {
    return {
      meta: isSet(object.meta) ? ResponseMeta.fromJSON(object.meta) : undefined,
      desired: isSet(object.desired) ? State.fromJSON(object.desired) : undefined,
      results: globalThis.Array.isArray(object?.results) ? object.results.map((e: any) => Result.fromJSON(e)) : [],
      context: isObject(object.context) ? object.context : undefined,
      requirements: isSet(object.requirements) ? Requirements.fromJSON(object.requirements) : undefined,
      conditions: globalThis.Array.isArray(object?.conditions)
        ? object.conditions.map((e: any) => Condition.fromJSON(e))
        : [],
    };
  },

  toJSON(message: RunFunctionResponse): unknown {
    const obj: any = {};
    if (message.meta !== undefined) {
      obj.meta = ResponseMeta.toJSON(message.meta);
    }
    if (message.desired !== undefined) {
      obj.desired = State.toJSON(message.desired);
    }
    if (message.results?.length) {
      obj.results = message.results.map((e) => Result.toJSON(e));
    }
    if (message.context !== undefined) {
      obj.context = message.context;
    }
    if (message.requirements !== undefined) {
      obj.requirements = Requirements.toJSON(message.requirements);
    }
    if (message.conditions?.length) {
      obj.conditions = message.conditions.map((e) => Condition.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<RunFunctionResponse>): RunFunctionResponse {
    return RunFunctionResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RunFunctionResponse>): RunFunctionResponse {
    const message = createBaseRunFunctionResponse();
    message.meta = (object.meta !== undefined && object.meta !== null)
      ? ResponseMeta.fromPartial(object.meta)
      : undefined;
    message.desired = (object.desired !== undefined && object.desired !== null)
      ? State.fromPartial(object.desired)
      : undefined;
    message.results = object.results?.map((e) => Result.fromPartial(e)) || [];
    message.context = object.context ?? undefined;
    message.requirements = (object.requirements !== undefined && object.requirements !== null)
      ? Requirements.fromPartial(object.requirements)
      : undefined;
    message.conditions = object.conditions?.map((e) => Condition.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRequestMeta(): RequestMeta {
  return { tag: "" };
}

export const RequestMeta: MessageFns<RequestMeta> = {
  encode(message: RequestMeta, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tag !== undefined && message.tag !== "") {
      writer.uint32(10).string(message.tag);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RequestMeta {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequestMeta();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.tag = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RequestMeta {
    return { tag: isSet(object.tag) ? globalThis.String(object.tag) : "" };
  },

  toJSON(message: RequestMeta): unknown {
    const obj: any = {};
    if (message.tag !== undefined && message.tag !== "") {
      obj.tag = message.tag;
    }
    return obj;
  },

  create(base?: DeepPartial<RequestMeta>): RequestMeta {
    return RequestMeta.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RequestMeta>): RequestMeta {
    const message = createBaseRequestMeta();
    message.tag = object.tag ?? "";
    return message;
  },
};

function createBaseRequirements(): Requirements {
  return { extraResources: {} };
}

export const Requirements: MessageFns<Requirements> = {
  encode(message: Requirements, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.extraResources || {}).forEach(([key, value]) => {
      Requirements_ExtraResourcesEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Requirements {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequirements();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          const entry1 = Requirements_ExtraResourcesEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.extraResources![entry1.key] = entry1.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Requirements {
    return {
      extraResources: isObject(object.extraResources)
        ? Object.entries(object.extraResources).reduce<{ [key: string]: ResourceSelector }>((acc, [key, value]) => {
          acc[key] = ResourceSelector.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: Requirements): unknown {
    const obj: any = {};
    if (message.extraResources) {
      const entries = Object.entries(message.extraResources);
      if (entries.length > 0) {
        obj.extraResources = {};
        entries.forEach(([k, v]) => {
          obj.extraResources[k] = ResourceSelector.toJSON(v);
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<Requirements>): Requirements {
    return Requirements.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Requirements>): Requirements {
    const message = createBaseRequirements();
    message.extraResources = Object.entries(object.extraResources ?? {}).reduce<{ [key: string]: ResourceSelector }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = ResourceSelector.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseRequirements_ExtraResourcesEntry(): Requirements_ExtraResourcesEntry {
  return { key: "", value: undefined };
}

export const Requirements_ExtraResourcesEntry: MessageFns<Requirements_ExtraResourcesEntry> = {
  encode(message: Requirements_ExtraResourcesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      ResourceSelector.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Requirements_ExtraResourcesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequirements_ExtraResourcesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = ResourceSelector.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Requirements_ExtraResourcesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? ResourceSelector.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Requirements_ExtraResourcesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = ResourceSelector.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<Requirements_ExtraResourcesEntry>): Requirements_ExtraResourcesEntry {
    return Requirements_ExtraResourcesEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Requirements_ExtraResourcesEntry>): Requirements_ExtraResourcesEntry {
    const message = createBaseRequirements_ExtraResourcesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? ResourceSelector.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseResourceSelector(): ResourceSelector {
  return { apiVersion: "", kind: "", matchName: undefined, matchLabels: undefined };
}

export const ResourceSelector: MessageFns<ResourceSelector> = {
  encode(message: ResourceSelector, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.apiVersion !== undefined && message.apiVersion !== "") {
      writer.uint32(10).string(message.apiVersion);
    }
    if (message.kind !== undefined && message.kind !== "") {
      writer.uint32(18).string(message.kind);
    }
    if (message.matchName !== undefined) {
      writer.uint32(26).string(message.matchName);
    }
    if (message.matchLabels !== undefined) {
      MatchLabels.encode(message.matchLabels, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResourceSelector {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResourceSelector();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.apiVersion = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.kind = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.matchName = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.matchLabels = MatchLabels.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResourceSelector {
    return {
      apiVersion: isSet(object.apiVersion) ? globalThis.String(object.apiVersion) : "",
      kind: isSet(object.kind) ? globalThis.String(object.kind) : "",
      matchName: isSet(object.matchName) ? globalThis.String(object.matchName) : undefined,
      matchLabels: isSet(object.matchLabels) ? MatchLabels.fromJSON(object.matchLabels) : undefined,
    };
  },

  toJSON(message: ResourceSelector): unknown {
    const obj: any = {};
    if (message.apiVersion !== undefined && message.apiVersion !== "") {
      obj.apiVersion = message.apiVersion;
    }
    if (message.kind !== undefined && message.kind !== "") {
      obj.kind = message.kind;
    }
    if (message.matchName !== undefined) {
      obj.matchName = message.matchName;
    }
    if (message.matchLabels !== undefined) {
      obj.matchLabels = MatchLabels.toJSON(message.matchLabels);
    }
    return obj;
  },

  create(base?: DeepPartial<ResourceSelector>): ResourceSelector {
    return ResourceSelector.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ResourceSelector>): ResourceSelector {
    const message = createBaseResourceSelector();
    message.apiVersion = object.apiVersion ?? "";
    message.kind = object.kind ?? "";
    message.matchName = object.matchName ?? undefined;
    message.matchLabels = (object.matchLabels !== undefined && object.matchLabels !== null)
      ? MatchLabels.fromPartial(object.matchLabels)
      : undefined;
    return message;
  },
};

function createBaseMatchLabels(): MatchLabels {
  return { labels: {} };
}

export const MatchLabels: MessageFns<MatchLabels> = {
  encode(message: MatchLabels, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.labels || {}).forEach(([key, value]) => {
      MatchLabels_LabelsEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MatchLabels {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMatchLabels();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          const entry1 = MatchLabels_LabelsEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.labels![entry1.key] = entry1.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MatchLabels {
    return {
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: MatchLabels): unknown {
    const obj: any = {};
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<MatchLabels>): MatchLabels {
    return MatchLabels.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MatchLabels>): MatchLabels {
    const message = createBaseMatchLabels();
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseMatchLabels_LabelsEntry(): MatchLabels_LabelsEntry {
  return { key: "", value: "" };
}

export const MatchLabels_LabelsEntry: MessageFns<MatchLabels_LabelsEntry> = {
  encode(message: MatchLabels_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MatchLabels_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMatchLabels_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MatchLabels_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: MatchLabels_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<MatchLabels_LabelsEntry>): MatchLabels_LabelsEntry {
    return MatchLabels_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MatchLabels_LabelsEntry>): MatchLabels_LabelsEntry {
    const message = createBaseMatchLabels_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseResponseMeta(): ResponseMeta {
  return { tag: "", ttl: undefined };
}

export const ResponseMeta: MessageFns<ResponseMeta> = {
  encode(message: ResponseMeta, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tag !== undefined && message.tag !== "") {
      writer.uint32(10).string(message.tag);
    }
    if (message.ttl !== undefined) {
      Duration.encode(message.ttl, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResponseMeta {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResponseMeta();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.tag = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.ttl = Duration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResponseMeta {
    return {
      tag: isSet(object.tag) ? globalThis.String(object.tag) : "",
      ttl: isSet(object.ttl) ? Duration.fromJSON(object.ttl) : undefined,
    };
  },

  toJSON(message: ResponseMeta): unknown {
    const obj: any = {};
    if (message.tag !== undefined && message.tag !== "") {
      obj.tag = message.tag;
    }
    if (message.ttl !== undefined) {
      obj.ttl = Duration.toJSON(message.ttl);
    }
    return obj;
  },

  create(base?: DeepPartial<ResponseMeta>): ResponseMeta {
    return ResponseMeta.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ResponseMeta>): ResponseMeta {
    const message = createBaseResponseMeta();
    message.tag = object.tag ?? "";
    message.ttl = (object.ttl !== undefined && object.ttl !== null) ? Duration.fromPartial(object.ttl) : undefined;
    return message;
  },
};

function createBaseState(): State {
  return { composite: undefined, resources: {} };
}

export const State: MessageFns<State> = {
  encode(message: State, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.composite !== undefined) {
      Resource.encode(message.composite, writer.uint32(10).fork()).join();
    }
    Object.entries(message.resources || {}).forEach(([key, value]) => {
      State_ResourcesEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): State {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.composite = Resource.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          const entry2 = State_ResourcesEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.resources![entry2.key] = entry2.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): State {
    return {
      composite: isSet(object.composite) ? Resource.fromJSON(object.composite) : undefined,
      resources: isObject(object.resources)
        ? Object.entries(object.resources).reduce<{ [key: string]: Resource }>((acc, [key, value]) => {
          acc[key] = Resource.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: State): unknown {
    const obj: any = {};
    if (message.composite !== undefined) {
      obj.composite = Resource.toJSON(message.composite);
    }
    if (message.resources) {
      const entries = Object.entries(message.resources);
      if (entries.length > 0) {
        obj.resources = {};
        entries.forEach(([k, v]) => {
          obj.resources[k] = Resource.toJSON(v);
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<State>): State {
    return State.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<State>): State {
    const message = createBaseState();
    message.composite = (object.composite !== undefined && object.composite !== null)
      ? Resource.fromPartial(object.composite)
      : undefined;
    message.resources = Object.entries(object.resources ?? {}).reduce<{ [key: string]: Resource }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = Resource.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseState_ResourcesEntry(): State_ResourcesEntry {
  return { key: "", value: undefined };
}

export const State_ResourcesEntry: MessageFns<State_ResourcesEntry> = {
  encode(message: State_ResourcesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Resource.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): State_ResourcesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseState_ResourcesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = Resource.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): State_ResourcesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Resource.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: State_ResourcesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Resource.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<State_ResourcesEntry>): State_ResourcesEntry {
    return State_ResourcesEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<State_ResourcesEntry>): State_ResourcesEntry {
    const message = createBaseState_ResourcesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? Resource.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseResource(): Resource {
  return { resource: undefined, connectionDetails: {}, ready: 0 };
}

export const Resource: MessageFns<Resource> = {
  encode(message: Resource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.resource !== undefined) {
      Struct.encode(Struct.wrap(message.resource), writer.uint32(10).fork()).join();
    }
    Object.entries(message.connectionDetails || {}).forEach(([key, value]) => {
      Resource_ConnectionDetailsEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    if (message.ready !== undefined && message.ready !== 0) {
      writer.uint32(24).int32(message.ready);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Resource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.resource = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          const entry2 = Resource_ConnectionDetailsEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.connectionDetails![entry2.key] = entry2.value;
          }
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.ready = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Resource {
    return {
      resource: isObject(object.resource) ? object.resource : undefined,
      connectionDetails: isObject(object.connectionDetails)
        ? Object.entries(object.connectionDetails).reduce<{ [key: string]: Uint8Array }>((acc, [key, value]) => {
          acc[key] = bytesFromBase64(value as string);
          return acc;
        }, {})
        : {},
      ready: isSet(object.ready) ? readyFromJSON(object.ready) : 0,
    };
  },

  toJSON(message: Resource): unknown {
    const obj: any = {};
    if (message.resource !== undefined) {
      obj.resource = message.resource;
    }
    if (message.connectionDetails) {
      const entries = Object.entries(message.connectionDetails);
      if (entries.length > 0) {
        obj.connectionDetails = {};
        entries.forEach(([k, v]) => {
          obj.connectionDetails[k] = base64FromBytes(v);
        });
      }
    }
    if (message.ready !== undefined && message.ready !== 0) {
      obj.ready = readyToJSON(message.ready);
    }
    return obj;
  },

  create(base?: DeepPartial<Resource>): Resource {
    return Resource.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Resource>): Resource {
    const message = createBaseResource();
    message.resource = object.resource ?? undefined;
    message.connectionDetails = Object.entries(object.connectionDetails ?? {}).reduce<{ [key: string]: Uint8Array }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = value;
        }
        return acc;
      },
      {},
    );
    message.ready = object.ready ?? 0;
    return message;
  },
};

function createBaseResource_ConnectionDetailsEntry(): Resource_ConnectionDetailsEntry {
  return { key: "", value: new Uint8Array(0) };
}

export const Resource_ConnectionDetailsEntry: MessageFns<Resource_ConnectionDetailsEntry> = {
  encode(message: Resource_ConnectionDetailsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value.length !== 0) {
      writer.uint32(18).bytes(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Resource_ConnectionDetailsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResource_ConnectionDetailsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Resource_ConnectionDetailsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? bytesFromBase64(object.value) : new Uint8Array(0),
    };
  },

  toJSON(message: Resource_ConnectionDetailsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value.length !== 0) {
      obj.value = base64FromBytes(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<Resource_ConnectionDetailsEntry>): Resource_ConnectionDetailsEntry {
    return Resource_ConnectionDetailsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Resource_ConnectionDetailsEntry>): Resource_ConnectionDetailsEntry {
    const message = createBaseResource_ConnectionDetailsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? new Uint8Array(0);
    return message;
  },
};

function createBaseResult(): Result {
  return { severity: 0, message: "", reason: undefined, target: undefined };
}

export const Result: MessageFns<Result> = {
  encode(message: Result, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.severity !== undefined && message.severity !== 0) {
      writer.uint32(8).int32(message.severity);
    }
    if (message.message !== undefined && message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.reason !== undefined) {
      writer.uint32(26).string(message.reason);
    }
    if (message.target !== undefined) {
      writer.uint32(32).int32(message.target);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Result {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.severity = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.reason = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.target = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Result {
    return {
      severity: isSet(object.severity) ? severityFromJSON(object.severity) : 0,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      reason: isSet(object.reason) ? globalThis.String(object.reason) : undefined,
      target: isSet(object.target) ? targetFromJSON(object.target) : undefined,
    };
  },

  toJSON(message: Result): unknown {
    const obj: any = {};
    if (message.severity !== undefined && message.severity !== 0) {
      obj.severity = severityToJSON(message.severity);
    }
    if (message.message !== undefined && message.message !== "") {
      obj.message = message.message;
    }
    if (message.reason !== undefined) {
      obj.reason = message.reason;
    }
    if (message.target !== undefined) {
      obj.target = targetToJSON(message.target);
    }
    return obj;
  },

  create(base?: DeepPartial<Result>): Result {
    return Result.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Result>): Result {
    const message = createBaseResult();
    message.severity = object.severity ?? 0;
    message.message = object.message ?? "";
    message.reason = object.reason ?? undefined;
    message.target = object.target ?? undefined;
    return message;
  },
};

function createBaseCondition(): Condition {
  return { type: "", status: 0, reason: "", message: undefined, target: undefined };
}

export const Condition: MessageFns<Condition> = {
  encode(message: Condition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== undefined && message.type !== "") {
      writer.uint32(10).string(message.type);
    }
    if (message.status !== undefined && message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    if (message.reason !== undefined && message.reason !== "") {
      writer.uint32(26).string(message.reason);
    }
    if (message.message !== undefined) {
      writer.uint32(34).string(message.message);
    }
    if (message.target !== undefined) {
      writer.uint32(40).int32(message.target);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Condition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCondition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.type = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.reason = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.message = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.target = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Condition {
    return {
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      status: isSet(object.status) ? statusFromJSON(object.status) : 0,
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
      message: isSet(object.message) ? globalThis.String(object.message) : undefined,
      target: isSet(object.target) ? targetFromJSON(object.target) : undefined,
    };
  },

  toJSON(message: Condition): unknown {
    const obj: any = {};
    if (message.type !== undefined && message.type !== "") {
      obj.type = message.type;
    }
    if (message.status !== undefined && message.status !== 0) {
      obj.status = statusToJSON(message.status);
    }
    if (message.reason !== undefined && message.reason !== "") {
      obj.reason = message.reason;
    }
    if (message.message !== undefined) {
      obj.message = message.message;
    }
    if (message.target !== undefined) {
      obj.target = targetToJSON(message.target);
    }
    return obj;
  },

  create(base?: DeepPartial<Condition>): Condition {
    return Condition.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Condition>): Condition {
    const message = createBaseCondition();
    message.type = object.type ?? "";
    message.status = object.status ?? 0;
    message.reason = object.reason ?? "";
    message.message = object.message ?? undefined;
    message.target = object.target ?? undefined;
    return message;
  },
};

/** A FunctionRunnerService is a Composition Function. */
export type FunctionRunnerServiceDefinition = typeof FunctionRunnerServiceDefinition;
export const FunctionRunnerServiceDefinition = {
  name: "FunctionRunnerService",
  fullName: "apiextensions.fn.proto.v1.FunctionRunnerService",
  methods: {
    /** RunFunction runs the Composition Function. */
    runFunction: {
      name: "RunFunction",
      requestType: RunFunctionRequest,
      requestStream: false,
      responseType: RunFunctionResponse,
      responseStream: false,
      options: {},
    },
  },
} as const;

export interface FunctionRunnerServiceImplementation<CallContextExt = {}> {
  /** RunFunction runs the Composition Function. */
  runFunction(
    request: RunFunctionRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<RunFunctionResponse>>;
}

export interface FunctionRunnerServiceClient<CallOptionsExt = {}> {
  /** RunFunction runs the Composition Function. */
  runFunction(
    request: DeepPartial<RunFunctionRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<RunFunctionResponse>;
}

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
